worried about ay?
  talk to ana about it - moving house, being tired
  talk to occ health about that
  talk to union
  get nick to verify that ref boxes was ready ages ago and generic comms is in use
  get rg to verify that stig is working and in use
  tell all concerned that it is only because I am worried that ay is looking for ways to discredit me that I am doing this.

sample grid - shelf and vessel wrong way round-
in fact, storage details should come after src box

ColDef



    
                                            
                                            
copyLocation
    position vs rack_pos vs tank_pos?
        src_box_pos is dupe of store_record->getPosition()

"An empty retrieval list" - null chunk!
        
what is paul doing with lua?

double-clicking a sample/box should mark the end of a chunk and create a new one

i started the coldef thing because I put the aliquot column in and it threw all the sorters out

---
sorters are not on correct columns; ColDef class is supposed to prevent this
'sorting' a column where values are largely the same (e.g. dest box "Example retrieval box 9") results in almost random sorting
things are 
            
# Sorting out the Sorter

   Test(std::vector<T *> & v) : vec(v) {}
   
   std::vector<SampleRow *>    vials;
   
   Test<SampleRow *> test(vials);

E2285 Could not find a match for 'Test<SampleRow *>::Test(vector<SampleRow *,allocator<SampleRow *> >)'

use typedef?
use pointer to vector instead of reference

now just passing function pointer to ColDef constructor is not right

E2034 Cannot convert 'bool(const SampleRow *,const SampleRow *)' to 'bool (*)(SampleRow * const *,SampleRow * const *)'
    notice ** double pointers
  
  - how did I do it with Sorter?

ah, because Sorter was specialized with SampleRow, and ColDef is being specialized with SampleRow *  
  
---
template <class T>
class Sorter {
public:
    bool (*sort_func_asc)(const T *, const T *); // ascending sort function
    std::string description;
    enum SortOrder { ASCENDING, DESCENDING, TOGGLE };
    void sort_asc(std::vector<T *> & vec) { sort(vec, ASCENDING);  }
    void sort_dsc(std::vector<T *> & vec) { sort(vec, DESCENDING);  }
    void sort_toggle(std::vector<T *> & vec) { sort(vec, TOGGLE);  }
private:
    SortOrder sortOrder; // last used sort order for toggle
    void sort(std::vector<T *> & vec, SortOrder order) {
        switch (order) {
            case ASCENDING:
                std::sort(vec.begin(), vec.end(), sort_func_asc);   break;
            case DESCENDING:
                std::sort(vec.rbegin(), vec.rend(), sort_func_asc); break; // reverse iterators
            case TOGGLE:
                sort(vec, sortOrder);
                sortOrder = (sortOrder == ASCENDING) ? DESCENDING : ASCENDING; // toggle
                break;
            default:
                throw Exception("Invalid sort order");
        }
    }
};

// declare sort asc/desc functions:

    static bool sort_asc_barcode(const SampleRow *a, const SampleRow *b)    { return a->cryovial_barcode.compare(b->cryovial_barcode) > 0; }
    static bool sort_desc_barcode(const SampleRow *a, const SampleRow *b)   { return a->cryovial_barcode.compare(b->cryovial_barcode) < 0; }
    static bool sort_asc_currbox(const SampleRow *a, const SampleRow *b)    { return Util::numericCompare(a->src_box_name, b->src_box_name); }
    static bool sort_desc_currbox(const SampleRow *a, const SampleRow *b)   { return Util::numericCompare(b->src_box_name, a->src_box_name); }
    static bool sort_asc_currpos(const SampleRow *a, const SampleRow *b)    { return a->store_record->getPosition() < b->store_record->getPosition(); }
    static bool sort_desc_currpos(const SampleRow *a, const SampleRow *b)   { return a->store_record->getPosition() > b->store_record->getPosition(); }
    static bool sort_asc_destbox(const SampleRow *a, const SampleRow *b)    { return Util::numericCompare(a->dest_box_name, b->dest_box_name); }
    static bool sort_desc_destbox(const SampleRow *a, const SampleRow *b)   { return Util::numericCompare(b->dest_box_name, a->dest_box_name); }

// declare sorter array:    

Sorter<SampleRow> sorter[SGVIALS_NUMCOLS] = {
    { SampleRow::sort_asc_barcode,   sgVialColName[SGVIALS_BARCODE] },
    { SampleRow::sort_asc_currbox,   sgVialColName[SGVIALS_CURRBOX] },
    ...
    
# Problems

 * asc and desc funcs both need to be declared - couldn't one be a reverse of the other?
   * already removed from class spec - implementations in SampleRow now redundant-taken out
 * why are the sort funcs implemented in SampleRow anyway?
 * using enum as parameter to Sorter::sort rather than calling sort_asc/desc/toggle directly seems unnecessary
 * separate Sorter array means it can get out of sync with column definitions - group together in (e.g.) ColDef?
   * does Sorter being a template make this a problem? the type T is e.g. SampleRow for all columns
   * 

/* enum {  SGVIALS_BARCODE, SGVIALS_ALIQUOT, SGVIALS_CURRBOX, SGVIALS_CURRPOS, SGVIALS_DESTBOX, SGVIALS_DESTPOS,
        SGVIALS_SITE, SGVIALS_POSITION, SGVIALS_SHELF, SGVIALS_VESSEL, SGVIALS_STRUCTURE, SGVIALS_SLOT, // location in "Russian Doll order"
        SGVIALS_NUMCOLS};
static const char * sgVialColName[SGVIALS_NUMCOLS] = {"Barcode", "Aliquot", "Curr box", "Pos", "Dest box", "Pos", "Site", "Position", "Shelf", "Vessel", "Structure", "Slot"};
static int sgVialColWidth[SGVIALS_NUMCOLS] = {102, 100, 275, 43, 275, 37, 64, 50, 43, 100, 121, 40}; */   

template <class T> // T is type of row to sort
class ColDef {
public:
    bool (*sort_func_asc)(const T *, const T *); // ascending sort function
    std::string name;
    std::string description; // sort description for (e.g.) combo box?
    int width; // for StringGrid::ColWidths[]
    enum SortOrder { ASCENDING, DESCENDING, TOGGLE };
    void sort_asc(std::vector<T *> & vec) { sort(vec, ASCENDING);  }
    void sort_dsc(std::vector<T *> & vec) { sort(vec, DESCENDING);  }
    void sort_toggle(std::vector<T *> & vec) { sort(vec, TOGGLE);  }
};

---
002000758 EDTA_BC SEARCH Buffy 7 / SEARCH buffy coat retrieval 330 Pos 8 
  Position give EAccessViolation and corrupt position, break on 
		if (found != samples.end()) { // fill in box location from cache map
            sample->site_name       = (*(found->second)).site_name; <-- here
            sample->position        = (*(found->second)).position;
            sample->vessel_name     = (*(found->second)).vessel_name; <-- or here
t_ldb1_ddb
(* == has locations)
### throwing errors
SEARCH May 2008
SEARCH BC Aug 2009 : Aug 2009 SEARCH Buffy Coat retrieval
* A cryovial retrieval for Chris
SEARCH BC 2003 : 2003 SEARCH Buffy Coat retrieval

### not throwing errors? 
THRIVE Lp(a) baseline : THRIVE Lp(a) analysis (big!)
SEARCH EDTA_1 Oct 2012 : Oct 2012 retrieval for myopathy biomarker
bianca rocca (box retrieval)
Retrieval_2415 : A job with a few THRIVE cryovial (no cryvials though?)
* Retrieval_2418 : Another THRIVE sample retrieval

must be thread-related? e.g. sample->store_record->getBoxID()?
non-threaded version seems ok... something in worker thread must be doing something gui-related... one of the classes descended from a VCL class?
void __fastcall LCDbCryoJobs::Renewal(TObject *)? timer in main thread though so should be ok
what if I take the synchronized updateStatus calls out?
  looked promising, but still crashing
be pragmatic, it seems to work non-threaded.
still much faster when locations are found, shouldn't be - is the query messing things up?
no, still crashes on notAThread
    on second load of same job <-- code smell
    vials not being reset/deleted?
    some other change I've made recently - follow it through from the start   
    unitialized map? clear?
    it was because the map was static

take out dupes:
int src_box_pos             s1.cryovial_position as source_pos // dupe
int src_box_id,             cryovial_store.box_cid // dupe
    
sort out SampleRow:
Member                      Constructor     Database

                            SampleRow(
                             LPDbCryovialStore * store_rec[
                             LPDbID         cryovial_store.cryovial_id
                             LDbNoteCount   cryovial_store.Note_Exists
                             retrievalID    cryovial_store.retrieval_cid
                             boxID          cryovial_store.box_cid
                             status         cryovial_store.status
                             position       cryovial_store.cryovial_position
                             cryovialID],   cryovial_store.cryovial_id
                             
string cryovial_barcode     barcode,        cryovial_barcode
string aliquot_type_name    aliquot,        aliquot_type_cid -> name
string src_box_name         src_name,       box_name.external_name
int dest_box_id             dest_id,        s2.box_cid
string dest_box_name        dest_name,      b2.external_name
int dest_box_pos            dest_pos        cryovial_position as dest_pos  # pos of cryovial in box/sample rack

string site_name            site,           c_tank_map.location_cid -> name
int vessel_pos              tank_pos,       c_tank_map.position as tank_pos? # current pos of vessel at site
string vessel_name          vessel,         c_tank_map.storage_cid -> name
int shelf_number            shelf,          c_tank_map.shelf_number # current pos of population within vessel (0: single population)                                
int structure_pos           rack_pos,       c_rack_number.position as rack_pos # pos of structure within population (in a vessel?) 1st structure in 1st section is at pos 1
int structure_name          rack_name,      c_rack_number.rack_cid -> name
int box_position           slot)           box_store.slot_position # pos of box/rack in structure    
    