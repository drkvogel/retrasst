is it initializing the ColDefs in frmSample() that's corrupting memory?
http://www.forbes.com/pictures/efkk45emdjk/16-things-you-should-do-at-the-start-of-every-work-day/
t_ldb1_ddb

(* == has locations)
### throwing errors
SEARCH May 2008
SEARCH BC Aug 2009 : Aug 2009 SEARCH Buffy Coat retrieval
* A cryovial retrieval for Chris
SEARCH BC 2003 : 2003 SEARCH Buffy Coat retrieval

"An empty retrieval list" - null chunk!

### not throwing errors? 
THRIVE Lp(a) baseline : THRIVE Lp(a) analysis (big!)
SEARCH EDTA_1 Oct 2012 : Oct 2012 retrieval for myopathy biomarker
bianca rocca (box retrieval)
Retrieval_2415 : A job with a few THRIVE cryovial (no cryvials though?)
* Retrieval_2418 : Another THRIVE sample retrieval

must be thread-related? e.g. sample->store_record->getBoxID()?
non-threaded version seems ok... something in worker thread must be doing something gui-related... one of the classes descended from a VCL class?
void __fastcall LCDbCryoJobs::Renewal(TObject *)? timer in main thread though so should be ok
what if I take the synchronized updateStatus calls out?
  looked promising, but still crashing
be pragmatic, it seems to work non-threaded.
still much faster when locations are found, shouldn't be - is the query messing things up?
no, still crashes on notAThread
    on second load of same job
    vials not being reset/deleted?
    some other change I've made recently - follow it through from the start

002000758 EDTA_BC SEARCH Buffy 7 / SEARCH buffy coat retrieval 330 Pos 8 
  Position give EAccessViolation and corrupt position, break on 
		if (found != samples.end()) { // fill in box location from cache map
            sample->site_name       = (*(found->second)).site_name; <-- here
            sample->position        = (*(found->second)).position;
            sample->vessel_name     = (*(found->second)).vessel_name; <-- or here
or
002000758 src box_id -40269

double-clicking a sample/box should mark the end of a chunk and create a new one

i started the coldef thing because I put the aliquot column in and it threw all the sorters out

---
sorters are not on correct columns; ColDef class is supposed to prevent this
'sorting' a column where values are largely the same (e.g. dest box "Example retrieval box 9") results in almost random sorting
things are 
            
# Sorting out the Sorter

   Test(std::vector<T *> & v) : vec(v) {}
   
   std::vector<SampleRow *>    vials;
   
   Test<SampleRow *> test(vials);

E2285 Could not find a match for 'Test<SampleRow *>::Test(vector<SampleRow *,allocator<SampleRow *> >)'

use typedef?
use pointer to vector instead of reference

now just passing function pointer to ColDef constructor is not right

E2034 Cannot convert 'bool(const SampleRow *,const SampleRow *)' to 'bool (*)(SampleRow * const *,SampleRow * const *)'
    notice ** double pointers
  
  - how did I do it with Sorter?

ah, because Sorter was specialized with SampleRow, and ColDef is being specialized with SampleRow *  
  
---
template <class T>
class Sorter {
public:
    bool (*sort_func_asc)(const T *, const T *); // ascending sort function
    std::string description;
    enum SortOrder { ASCENDING, DESCENDING, TOGGLE };
    void sort_asc(std::vector<T *> & vec) { sort(vec, ASCENDING);  }
    void sort_dsc(std::vector<T *> & vec) { sort(vec, DESCENDING);  }
    void sort_toggle(std::vector<T *> & vec) { sort(vec, TOGGLE);  }
private:
    SortOrder sortOrder; // last used sort order for toggle
    void sort(std::vector<T *> & vec, SortOrder order) {
        switch (order) {
            case ASCENDING:
                std::sort(vec.begin(), vec.end(), sort_func_asc);   break;
            case DESCENDING:
                std::sort(vec.rbegin(), vec.rend(), sort_func_asc); break; // reverse iterators
            case TOGGLE:
                sort(vec, sortOrder);
                sortOrder = (sortOrder == ASCENDING) ? DESCENDING : ASCENDING; // toggle
                break;
            default:
                throw Exception("Invalid sort order");
        }
    }
};

// declare sort asc/desc functions:

    static bool sort_asc_barcode(const SampleRow *a, const SampleRow *b)    { return a->cryovial_barcode.compare(b->cryovial_barcode) > 0; }
    static bool sort_desc_barcode(const SampleRow *a, const SampleRow *b)   { return a->cryovial_barcode.compare(b->cryovial_barcode) < 0; }
    static bool sort_asc_currbox(const SampleRow *a, const SampleRow *b)    { return Util::numericCompare(a->src_box_name, b->src_box_name); }
    static bool sort_desc_currbox(const SampleRow *a, const SampleRow *b)   { return Util::numericCompare(b->src_box_name, a->src_box_name); }
    static bool sort_asc_currpos(const SampleRow *a, const SampleRow *b)    { return a->store_record->getPosition() < b->store_record->getPosition(); }
    static bool sort_desc_currpos(const SampleRow *a, const SampleRow *b)   { return a->store_record->getPosition() > b->store_record->getPosition(); }
    static bool sort_asc_destbox(const SampleRow *a, const SampleRow *b)    { return Util::numericCompare(a->dest_box_name, b->dest_box_name); }
    static bool sort_desc_destbox(const SampleRow *a, const SampleRow *b)   { return Util::numericCompare(b->dest_box_name, a->dest_box_name); }

// declare sorter array:    

Sorter<SampleRow> sorter[SGVIALS_NUMCOLS] = {
    { SampleRow::sort_asc_barcode,   sgVialColName[SGVIALS_BARCODE] },
    { SampleRow::sort_asc_currbox,   sgVialColName[SGVIALS_CURRBOX] },
    ...
    
# Problems

 * asc and desc funcs both need to be declared - couldn't one be a reverse of the other?
   * already removed from class spec - implementations in SampleRow now redundant-taken out
 * why are the sort funcs implemented in SampleRow anyway?
 * using enum as parameter to Sorter::sort rather than calling sort_asc/desc/toggle directly seems unnecessary
 * separate Sorter array means it can get out of sync with column definitions - group together in (e.g.) ColDef?
   * does Sorter being a template make this a problem? the type T is e.g. SampleRow for all columns
   * 

/* enum {  SGVIALS_BARCODE, SGVIALS_ALIQUOT, SGVIALS_CURRBOX, SGVIALS_CURRPOS, SGVIALS_DESTBOX, SGVIALS_DESTPOS,
        SGVIALS_SITE, SGVIALS_POSITION, SGVIALS_SHELF, SGVIALS_VESSEL, SGVIALS_STRUCTURE, SGVIALS_SLOT, // location in "Russian Doll order"
        SGVIALS_NUMCOLS};
static const char * sgVialColName[SGVIALS_NUMCOLS] = {"Barcode", "Aliquot", "Curr box", "Pos", "Dest box", "Pos", "Site", "Position", "Shelf", "Vessel", "Structure", "Slot"};
static int sgVialColWidth[SGVIALS_NUMCOLS] = {102, 100, 275, 43, 275, 37, 64, 50, 43, 100, 121, 40}; */   

template <class T> // T is type of row to sort
class ColDef {
public:
    bool (*sort_func_asc)(const T *, const T *); // ascending sort function
    std::string name;
    std::string description; // sort description for (e.g.) combo box?
    int width; // for StringGrid::ColWidths[]
    enum SortOrder { ASCENDING, DESCENDING, TOGGLE };
    void sort_asc(std::vector<T *> & vec) { sort(vec, ASCENDING);  }
    void sort_dsc(std::vector<T *> & vec) { sort(vec, DESCENDING);  }
    void sort_toggle(std::vector<T *> & vec) { sort(vec, TOGGLE);  }
};

