//---------------------------------------------------------------------------

#ifndef TLogFrameH
#define TLogFrameH
//---------------------------------------------------------------------------
#include <System.Classes.hpp>
#include <FMX.Controls.hpp>
#include <FMX.Forms.hpp>
#include <FMX.Layouts.hpp>
#include <FMX.ListBox.hpp>
#include <FMX.StdCtrls.hpp>
#include <FMX.Types.hpp>
//---------------------------------------------------------------------------
#include "CritSec.h"
#include <deque>
#include <string>

/** Represents a message string with some additional characteristics, which
  * will dictate how such a message would get displayed in the logging window.
  */
struct LabelledMessage
{
/** Used to flag up messages intended for the GUI side of the
  * logging window.
  */
	static int PURPOSE_GUI;

/** Used to flag up message intended for the Business Layer side of the
  * logging window.
  */
	static int PURPOSE_BUSINESS_LAYER;


	int         purpose;        ///< e.g. is it from the GUI or Business Layer?
	bool        highlight;      ///< does it need highlighting?
	std::string message;        ///< the text of the message
};

/** An instance of this thread is used as a message queue for communicating
  * between the logging window, and the threads generated by the logging service
  * from log messages sent to it.
  * The contents of the queue are LabelledMessage objects, messages labelled
  * with some distinguishing characteristics.
  *
  * Methods of this class accessing the queue are critical sections,
  * and these are protected by a lock (paulst::CritSec).
  *
  * For details of how this queue is used for communication between threads,
  * please see the documentation for TloggingForm.
  */
class LogMessageQueue {
public:
	LogMessageQueue();
	~LogMessageQueue();
	void addMsgToQ(const LabelledMessage & lmsg);
	LabelledMessage removeMsgFromQ();
private:
	paulst::CritSec queueLock;       // to make sure that two threads don't try
									 // and execute the critical sections of code
									 // that access the queue at the same time

	std::deque<LabelledMessage> q;   // the message queue itself

	LogMessageQueue(const LogMessageQueue &);             // unimplemented & private
	LogMessageQueue & operator=(const LogMessageQueue &); // for uncopyability
};


class TLogFrame : public TFrame
{
__published:	// IDE-managed Components
	TLayout *TopLabelsArea;
	TLabel *Label2;
	TLabel *Label3;
	TLayout *DualPane;
	TListBox *BLlistbox;
	TListBox *GUIlistbox;
	TStyleBook *StyleBook2;
private:	// User declarations
public:		// User declarations
	__fastcall TLogFrame(TComponent* Owner);

    void onResize();
    void __fastcall processNextMessage();
    void queueMessage( const LabelledMessage& lm );

private:
	int maxLineLength = 65;  // quick and dirty hack, for implementing line
							 // wrapping, since the list items won't

	LogMessageQueue msgQueue; // the message queue for communication between
							  // writing threads generated by the logging service
							  // and GUI updates for the logging window itself


	void addMsgToListBox(const std::string & msg, TListBox *box, bool highlighting);
	void appendMessageToLogWindow(const LabelledMessage & msg);
	void scrollDown(TListBox *box);
};
//---------------------------------------------------------------------------
extern PACKAGE TLogFrame *LogFrame;
//---------------------------------------------------------------------------
#endif

